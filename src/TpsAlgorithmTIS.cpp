/*
LibTPS -- A Transition Path Sampling Library
(LibTPS) Open Source Software License Copyright 2012 The Regents of the 
University of Michigan All rights reserved.

LibTPS may contain modifications ("Contributions") provided, and to which
copyright is held, by various Contributors who have granted The Regents of the
University of Michigan the right to modify and/or distribute such Contributions.

You may redistribute, use, and create derivate works of LibTPS, in source
and binary forms, provided you abide by the following conditions:

* Redistributions of source code must retain the above copyright notice, this
list of conditions, and the following disclaimer both in the code and
prominently in any materials provided with the distribution.

* Redistributions in binary form must reproduce the above copyright notice, this
list of conditions, and the following disclaimer in the documentation and/or
other materials provided with the distribution.

* Apart from the above required attributions, neither the name of the copyright
holder nor the names of LibTPS's contributors may be used to endorse or
promote products derived from this software without specific prior written
permission.

Disclaimer

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND/OR ANY
WARRANTIES THAT THIS SOFTWARE IS FREE OF INFRINGEMENT ARE DISCLAIMED.

IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
 *  TpsAlgorithmTIS.cpp
 *  tpsapi
 *
 *  Created by askeys on 11/14/08.
 *  Copyright 2008 The Regents of the University of Michigan. 
 *  All rights reserved.
 *
 */

#include "TpsAlgorithmTIS.h"

TpsAlgorithmTIS::TpsAlgorithmTIS(TpsTrajectoryEnsemble& t, 
	TpsRNG& r, TpsOrderParameter& f, TpsInitializer& i)
:	TpsAlgorithm(t, r, f), _initializer(i)
{
}
		
TpsAlgorithmTIS::~TpsAlgorithmTIS()
{
}

void TpsAlgorithmTIS::doStep()
{
	/*
	1. Take a uniform random number y1 in the interval [0 : 1]. If y1 < α perform a 
	time-reversal move. Otherwise, perform a shooting move. 
	2. If the trial path generated by either the time-reversal or shooting move is a 
	proper path in the λi ensemble accept the move and replace the old path by the 
	new one, otherwise keep the old path. 
	3. Update averages on the path 
	4. Repeat from step 1.
	*/
	
	/*
	if (_rng.randUniform() < _probability_shot) {
		_shot.attempt(*this);
	}
	else {
		_path_reversal.attempt(*this);
	}
	*/
	
}


void shot()
{
/*
1. On the current path with length N (o) choose a random time slice τ ′ , with 
−τ 
b 
≤ τ ′ ≤ τ 
f 
. 
2. Change all momenta of the particles at time-slice τ by adding small randomized 
displacements δp = δw√m with δw taken from a Gaussian distribution with 
width σw and m the mass of the particle. 
3. In case of constant temperature (NVT) path sampling simulations accept the 
new momenta with a probability 
. 
Here, E(x) is the total energy of the system at phase space point x. In case 
of constant energy (NVE) simulations, in which possibly also total linear- or 
angular momentum should be conserved, rescale all the momenta of the system 
according to the procedure described in sec 2.2.1 and accept or reject the new 
rescaled momenta. 
If the new momenta are accepted continue with step 4, else reject the whole 
shooting move and return to the main loop. 
4. Take a uniform random number y2 in the interval [0 : 1] and determine a 
maximum allowed path length for the trial move by: 
N (n) 
max = int(N (o) /y2 ). 
5. Integrate equations of motion backward in time by reversing the momenta at 
time slice τ ′ , until reaching either λ0 , λi+1 or exceeding the maximum path 
length N (n) 
max . If the backward tra jectory did not reach λ0 reject and go back 
the main loop. Otherwise continue with step 6. 
6. Integrate from time slice τ ′ forward until reaching either λ0 , λi+1 or exceeding 
the maximum path length N (n) 
max . Reject and go back to the main loop if the 
maximum path length is exceeded or if the entire trial path has no crossing with 
interface λi . Otherwise continue with the next step. 
7. Accept the new path, reassign x0 to be the ﬁrst crossing point with λi and 
return to the main loop. 


	int num = controller.getPathNumber();
	TpsTrajectory& old_trajectory = _trajectory_factory.getTrajectory(num);
	TpsTrajectory& new_trajectory = _trajectory_factory.getTrajectory(-1);
	TpsRNG& rng = controller.getRNG();
	TpsOrderParameter& path_function = controller.getPathFunction();
	
	new_trajectory.clear();
	int path_length = _old_path_length / _rng.randUniform();
	new_trajectory.shootFrom(old_trajectory, rng, _perturbation);	
	
	while(1) {
		_times.push_back(t);
		new_trajectory.extendBackward(times);
		if (new_trajectory.getLength() > path_length) {
			reject;
		}
	}	
	
	
	if(path_function.hA(new_trajectory)) {
		new_trajectory.extendForward();
		//depending on what we are doing, we may want to count
		//paths that end in B (hb) or paths that visit B (HB)
		if(path_function.hBorHB(new_trajectory)) {
			controller.getTrajectoryFactory().moveTrajectory(-1, num+1);
			controller.incrementPathNumber();
			return true;
		}
	}
	old_trajectory.incrementWeight();	
	return false;
	*/


}